<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hospital Access Analysis</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <!-- Fixed Turf.js CDN link -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
        }
        #map {
            width: 100%;
            height: 85vh;
            z-index: 1;
        }
        .header {
            padding: 20px;
            background-color: #2c3e50;
            color: white;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            margin: 0;
            font-size: 28px;
        }
        .subtitle {
            font-size: 16px;
            margin-top: 10px;
            opacity: 0.8;
        }
        .legend {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            max-width: 300px;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .location-button {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            font-weight: bold;
        }
        .location-button:hover {
            background: #f0f0f0;
        }
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #2c3e50;
            color: white;
            padding: 5px 20px;
            font-size: 14px;
            z-index: 1000;
        }
        .progress-container {
            width: 80%;
            margin-top: 20px;
            background-color: #f3f3f3;
            border-radius: 5px;
            overflow: hidden;
        }
        .progress-bar {
            height: 30px;
            background-color: #3498db;
            width: 0%;
            text-align: center;
            line-height: 30px;
            color: white;
            transition: width 0.3s;
        }
        #console-output {
            position: fixed;
            bottom: 30px;
            left: 20px;
            width: 400px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 10px;
            font-family: monospace;
            border-radius: 5px;
            z-index: 1001;
            display: none;
        }
        .toggle-console {
            position: fixed;
            bottom: 30px;
            left: 20px;
            z-index: 1002;
            background: #333;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Hospital Accessibility Analysis</h1>
        <div class="subtitle">Comparing drive times between Soroka Medical Center and New Hospital</div>
    </div>
    
    <div id="map"></div>
    
    <div class="legend">
        <h3 style="margin-top: 0; margin-bottom: 10px;">Legend</h3>
        <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(0, 0, 255, 0.7);"></div>
            <div>Faster to Soroka Medical Center</div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(255, 0, 0, 0.7);"></div>
            <div>Faster to New Hospital</div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(128, 0, 128, 0.7);"></div>
            <div>Equal Access (< 2 min difference)</div>
        </div>
    </div>
    
    <div class="info-panel">
        <h3 style="margin-top: 0;">Analysis Parameters</h3>
        <p><strong>Radius:</strong> 30 km</p>
        <p><strong>Grid size:</strong> <span id="gridSize">1</span> km (<span id="totalPoints">0</span> points)</p>
        <p><strong>Mode:</strong> CAR</p>
        <div>
            <label for="gridSizeSlider">Grid resolution:</label>
            <input type="range" id="gridSizeSlider" min="0.5" max="2" step="0.25" value="1">
        </div>
        <div>
            <label for="batchSizeSelect">Batch size:</label>
            <select id="batchSizeSelect">
                <option value="5">5 (Slower but more stable)</option>
                <option value="10" selected>10 (Balanced)</option>
                <option value="20">20 (Faster but may fail)</option>
            </select>
        </div>
        <button id="runAnalysis" style="margin-top: 10px; padding: 8px 12px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">Run Analysis</button>
        <button id="stopAnalysis" style="margin-top: 10px; padding: 8px 12px; background-color: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Stop Analysis</button>
    </div>
    
    <button class="location-button" id="locateMe">üìç Locate Me</button>
    <button class="toggle-console" id="toggleConsole">Show Console</button>
    
    <div id="console-output"></div>
    
    <div class="status-bar">
        <span id="statusText">Ready for analysis</span>
    </div>
    
    <div class="loading" id="loadingScreen">
        <div class="spinner"></div>
        <div id="progressText">Preparing analysis...</div>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar">0%</div>
        </div>
    </div>
    
    <script>
        // Enhanced console logging
        const consoleOutput = document.getElementById('console-output');
        const logger = {
            log: function(message) {
                console.log(message);
                const logEntry = document.createElement('div');
                logEntry.textContent = `[INFO] ${message}`;
                consoleOutput.appendChild(logEntry);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            },
            error: function(message) {
                console.error(message);
                const logEntry = document.createElement('div');
                logEntry.textContent = `[ERROR] ${message}`;
                logEntry.style.color = '#ff5252';
                consoleOutput.appendChild(logEntry);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            },
            warn: function(message) {
                console.warn(message);
                const logEntry = document.createElement('div');
                logEntry.textContent = `[WARN] ${message}`;
                logEntry.style.color = '#ffd600';
                consoleOutput.appendChild(logEntry);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
        };
        
        // Toggle console visibility
        document.getElementById('toggleConsole').addEventListener('click', function() {
            const consoleOutput = document.getElementById('console-output');
            const isHidden = consoleOutput.style.display === 'none';
            consoleOutput.style.display = isHidden ? 'block' : 'none';
            this.textContent = isHidden ? 'Hide Console' : 'Show Console';
        });
        
        // Hospital coordinates
        const soroka = [31.258048100012424, 34.800391059526504];
        const newHospital = [31.225231573088337, 34.828545558768404];
        
        // Control variable to allow stopping analysis
        let analysisRunning = false;
        
        // Initialize map
        logger.log("Initializing map...");
        const map = L.map('map').setView([31.240, 34.815], 11);
        
        // Add basemap layers
        const sateliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });
        
        const streetLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(map);
        
        const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        });
        
        logger.log("Map initialized with base layers");
        
        // Add layer control
        const baseLayers = {
            "Light": streetLayer,
            "Dark": darkLayer,
            "Satellite": sateliteLayer
        };
        
        L.control.layers(baseLayers).addTo(map);
        
        // Add hospital markers
        const sorokaMarker = L.marker(soroka)
            .addTo(map)
            .bindPopup("<b>Soroka Medical Center</b><br>Major medical facility");
            
        const newHospitalMarker = L.marker(newHospital)
            .addTo(map)
            .bindPopup("<b>New Hospital</b><br>Recently built facility");
        
        logger.log("Added hospital markers");
        
        // Add circle showing the 30km analysis radius
        const analysisCenter = [(soroka[0] + newHospital[0]) / 2, (soroka[1] + newHospital[1]) / 2];
        const radiusCircle = L.circle(analysisCenter, {
            radius: 30000,
            color: '#2c3e50',
            fillColor: '#2c3e50',
            fillOpacity: 0.05,
            weight: 2,
            dashArray: '5,10'
        }).addTo(map);
        
        logger.log("Added 30km radius circle");
        
        // Create layer group for analysis results
        const resultsLayer = L.layerGroup().addTo(map);
        
        // Function to generate grid points within radius
        function generateGrid(center, radius, gridSize) {
            logger.log(`Generating grid with center [${center}], radius ${radius}km, grid size ${gridSize}km`);
            
            try {
                const points = [];
                const radiusInDegrees = radius / 111;
                
                // Calculate bounding box
                const latDelta = radius / 111;
                const lonDelta = radius / (111 * Math.cos(center[0] * Math.PI / 180));
                
                const bbox = [
                    center[1] - lonDelta, // west
                    center[0] - latDelta, // south
                    center[1] + lonDelta, // east
                    center[0] + latDelta  // north
                ];
                
                logger.log(`Bounding box: W:${bbox[0].toFixed(4)}, S:${bbox[1].toFixed(4)}, E:${bbox[2].toFixed(4)}, N:${bbox[3].toFixed(4)}`);
                
                // Calculate step size in degrees
                const gridSizeInDegreesLat = gridSize / 111;
                const gridSizeInDegreesLon = gridSize / (111 * Math.cos(center[0] * Math.PI / 180));
                
                logger.log(`Grid size in degrees: ${gridSizeInDegreesLat.toFixed(6)} lat, ${gridSizeInDegreesLon.toFixed(6)} lon`);
                
                // Generate points
                for (let lat = bbox[1]; lat <= bbox[3]; lat += gridSizeInDegreesLat) {
                    for (let lon = bbox[0]; lon <= bbox[2]; lon += gridSizeInDegreesLon) {
                        const point = [lat, lon];
                        
                        // Calculate distance from center using haversine formula
                        const dLat = (center[0] - lat) * Math.PI / 180;
                        const dLon = (center[1] - lon) * Math.PI / 180;
                        const a = 
                            Math.sin(dLat/2) * Math.sin(dLat/2) +
                            Math.cos(lat * Math.PI / 180) * Math.cos(center[0] * Math.PI / 180) * 
                            Math.sin(dLon/2) * Math.sin(dLon/2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                        const distance = 6371 * c; // Earth radius in km
                        
                        if (distance <= radius) {
                            points.push(point);
                        }
                    }
                }
                
                logger.log(`Generated ${points.length} points within ${radius}km radius`);
                document.getElementById('totalPoints').textContent = points.length;
                return points;
            } catch (error) {
                logger.error(`Error generating grid: ${error.message}`);
                console.error("Full error:", error);
                return [];
            }
        }
        
        // Update estimated point count on page load
        (function updateInitialPointCount() {
            try {
                const gridSize = parseFloat(document.getElementById('gridSizeSlider').value);
                document.getElementById('gridSize').textContent = gridSize;
                
                const center = [(soroka[0] + newHospital[0]) / 2, (soroka[1] + newHospital[1]) / 2];
                const points = generateGrid(center, 30, gridSize);
                document.getElementById('totalPoints').textContent = points.length;
                logger.log(`Initial point count: ${points.length}`);
            } catch (error) {
                logger.error(`Error calculating initial point count: ${error.message}`);
            }
        })();
        
        // OTP API functions
        async function getRouteTime(origin, destination) {
            try {
                const url = `http://localhost:8080/otp/routers/default/plan?fromPlace=${origin[0]},${origin[1]}&toPlace=${destination[0]},${destination[1]}&mode=CAR&time=12:00pm&date=03-03-2025`;
                
                logger.log(`Fetching route: ${origin[0].toFixed(4)},${origin[1].toFixed(4)} to ${destination[0].toFixed(4)},${destination[1].toFixed(4)}`);
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.plan && data.plan.itineraries && data.plan.itineraries.length > 0) {
                    const duration = data.plan.itineraries[0].duration;
                    logger.log(`Route found: ${Math.round(duration/60)} minutes`);
                    return duration;
                } else {
                    logger.warn(`No route found between ${origin[0].toFixed(4)},${origin[1].toFixed(4)} and ${destination[0].toFixed(4)},${destination[1].toFixed(4)}`);
                    return null;
                }
            } catch (error) {
                logger.error(`Error fetching route: ${error.message}`);
                return null;
            }
        }
        
        // Main analysis function
        async function runAnalysis() {
            if (analysisRunning) {
                logger.warn("Analysis already in progress");
                return;
            }
            
            analysisRunning = true;
            
            const gridSize = parseFloat(document.getElementById('gridSizeSlider').value);
            document.getElementById('gridSize').textContent = gridSize;
            
            const batchSize = parseInt(document.getElementById('batchSizeSelect').value);
            logger.log(`Starting analysis with grid size ${gridSize}km and batch size ${batchSize}`);
            
            // Show loading screen and stop button
            document.getElementById('loadingScreen').style.display = 'flex';
            document.getElementById('runAnalysis').style.display = 'none';
            document.getElementById('stopAnalysis').style.display = 'block';
            document.getElementById('progressText').textContent = 'Generating analysis grid...';
            document.getElementById('statusText').textContent = 'Analysis running...';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressBar').textContent = '0%';
            
            // Clear previous results
            resultsLayer.clearLayers();
            logger.log("Cleared previous results");
            
            // Allow UI to update
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Generate grid points
            const gridPoints = generateGrid(analysisCenter, 30, gridSize);
            
            if (gridPoints.length === 0) {
                logger.error("Failed to generate grid points. Stopping analysis.");
                analysisRunning = false;
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('runAnalysis').style.display = 'block';
                document.getElementById('stopAnalysis').style.display = 'none';
                document.getElementById('statusText').textContent = 'Analysis failed: Could not generate grid points';
                return;
            }
            
            let processed = 0;
            let successes = 0;
            let failures = 0;
            const results = [];
            
            // Process in batches to avoid overwhelming the API
            for (let i = 0; i < gridPoints.length && analysisRunning; i += batchSize) {
                const batch = gridPoints.slice(i, i + batchSize);
                const batchPromises = batch.map(async (point, index) => {
                    if (!analysisRunning) return;
                    
                    try {
                        logger.log(`Processing point ${processed + index + 1}/${gridPoints.length}: [${point[0].toFixed(4)}, ${point[1].toFixed(4)}]`);
                        
                        const timeToSoroka = await getRouteTime(point, soroka);
                        if (!analysisRunning) return;
                        
                        const timeToNewHospital = await getRouteTime(point, newHospital);
                        if (!analysisRunning) return;
                        
                        if (timeToSoroka !== null && timeToNewHospital !== null) {
                            const timeDiff = timeToSoroka - timeToNewHospital; // positive: new hospital is faster
                            successes++;
                            results.push({
                                point: point,
                                timeDiff: timeDiff,
                                timeToSoroka: timeToSoroka,
                                timeToNewHospital: timeToNewHospital
                            });
                            
                            // Add point to map immediately for visual feedback
                            displayPoint({
                                point: point,
                                timeDiff: timeDiff,
                                timeToSoroka: timeToSoroka,
                                timeToNewHospital: timeToNewHospital
                            });
                        } else {
                            failures++;
                            logger.warn(`Failed to get route for point [${point[0].toFixed(4)}, ${point[1].toFixed(4)}]`);
                        }
                    } catch (error) {
                        failures++;
                        logger.error(`Error processing point ${processed + index + 1}: ${error.message}`);
                    }
                });
                
                await Promise.all(batchPromises);
                
                processed += batch.length;
                
                // Update progress
                const progressPercent = Math.round((processed / gridPoints.length) * 100);
                document.getElementById('progressBar').style.width = `${progressPercent}%`;
                document.getElementById('progressBar').textContent = `${progressPercent}%`;
                document.getElementById('progressText').textContent = 
                    `Processed ${processed} of ${gridPoints.length} points (${successes} successful, ${failures} failed)`;
                document.getElementById('statusText').textContent = 
                    `Analysis in progress: ${progressPercent}% complete`;
                
                // Small delay to prevent overwhelming the server
                if (analysisRunning) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
            
            // Update final status
            if (!analysisRunning) {
                document.getElementById('statusText').textContent = `Analysis stopped by user after processing ${processed} points`;
                logger.log("Analysis stopped by user");
            } else {
                document.getElementById('statusText').textContent = `Analysis complete: ${results.length} points processed (${failures} failed)`;
                logger.log(`Analysis complete: ${results.length} points processed successfully, ${failures} failed`);
            }
            
            // Hide loading screen and restore run button
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('runAnalysis').style.display = 'block';
            document.getElementById('stopAnalysis').style.display = 'none';
            
            analysisRunning = false;
        }
        
        // Function to display a point result on the map
        function displayPoint(result) {
            const { point, timeDiff, timeToSoroka, timeToNewHospital } = result;
            
            let color, fillColor, radius;
            
            if (Math.abs(timeDiff) < 120) { // Less than 2 minutes difference
                fillColor = 'rgba(128, 0, 128, 0.7)'; // Purple for balanced
                color = '#4B0082';
            } else if (timeDiff > 0) { // New hospital is faster
                fillColor = 'rgba(255, 0, 0, 0.7)'; // Red for new hospital
                color = '#8B0000';
            } else { // Soroka is faster
                fillColor = 'rgba(0, 0, 255, 0.7)'; // Blue for Soroka
                color = '#00008B';
            }
            
            // Size based on absolute time difference
            radius = 200 + (Math.min(Math.abs(timeDiff) / 60, 20) * 100);
            
            const circle = L.circle(point, {
                radius: radius,
                color: color,
                fillColor: fillColor,
                fillOpacity: 0.6,
                weight: 1
            }).addTo(resultsLayer);
            
            // Popup info
            const sorokaTime = Math.round(timeToSoroka / 60);
            const newHospitalTime = Math.round(timeToNewHospital / 60);
            const difference = Math.abs(Math.round(timeDiff / 60));
            
            let fasterHospital;
            if (Math.abs(timeDiff) < 120) {
                fasterHospital = "Equal access (< 2 min difference)";
            } else if (timeDiff > 0) {
                fasterHospital = `New Hospital is faster by ${difference} min`;
            } else {
                fasterHospital = `Soroka is faster by ${difference} min`;
            }
            
            circle.bindPopup(`
                <strong>Access Times:</strong><br>
                Soroka Medical Center: ${sorokaTime} minutes<br>
                New Hospital: ${newHospitalTime} minutes<br>
                <strong>${fasterHospital}</strong>
            `);
        }
        
        // Event listeners
        document.getElementById('runAnalysis').addEventListener('click', runAnalysis);
        
        document.getElementById('stopAnalysis').addEventListener('click', function() {
            logger.log("User requested to stop analysis");
            analysisRunning = false;
            document.getElementById('progressText').textContent = 'Stopping analysis...';
        });
        
        document.getElementById('gridSizeSlider').addEventListener('input', function() {
            try {
                const gridSize = parseFloat(this.value);
                document.getElementById('gridSize').textContent = gridSize;
                
                // Update estimated point count
                const points = generateGrid(analysisCenter, 30, gridSize);
                document.getElementById('totalPoints').textContent = points.length;
            } catch (error) {
                logger.error(`Error updating point count: ${error.message}`);
            }
        });
        
        document.getElementById('locateMe').addEventListener('click', function() {
            logger.log("User requested location");
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    const userLocation = [position.coords.latitude, position.coords.longitude];
                    logger.log(`User location found: ${userLocation[0].toFixed(4)}, ${userLocation[1].toFixed(4)}`);
                    
                    map.setView(userLocation, 13);
                    
                    L.marker(userLocation, {
                        icon: L.divIcon({
                            className: 'user-location',
                            html: '<div style="background-color: #3498db; width: 15px; height: 15px; border-radius: 50%; border: 3px solid white;"></div>',
                            iconSize: [15, 15],
                            iconAnchor: [8, 8]
                        })
                    }).addTo(map).bindPopup("Your location").openPopup();
                    
                }, error => {
                    logger.error(`Error getting location: ${error.message} (code: ${error.code})`);
                    alert("Unable to get your location. Please check your browser permissions.");
                });
            } else {
                logger.warn("Geolocation is not supported by this browser");
                alert("Geolocation is not supported by your browser.");
            }
        });
        
        // Export data option
        function exportToCSV(data) {
            const csvRows = [];
            
            // Add header
            csvRows.push("latitude,longitude,timeToSoroka,timeToNewHospital,timeDifference,fasterHospital");
            
            // Add rows
            data.forEach(item => {
                const fasterHospital = item.timeDiff < 0 ? "Soroka" : item.timeDiff > 0 ? "NewHospital" : "Equal";
                csvRows.push(
                    `${item.point[0]},${item.point[1]},${item.timeToSoroka},${item.timeToNewHospital},${item.timeDiff},${fasterHospital}`
                );
            });
            
            // Create blob and download
            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'hospital_analysis.csv');
            link.click();
        }
        
        // Add export button to info panel
        const exportButton = document.createElement('button');
        exportButton.textContent = 'Export Results';
        exportButton.style.marginTop = '10px';
        exportButton.style.padding = '8px 12px';
        exportButton.style.backgroundColor = '#27ae60';
        exportButton.style.color = 'white';
        exportButton.style.border = 'none';
        exportButton.style.borderRadius = '4px';
        exportButton.style.cursor = 'pointer';
        exportButton.onclick = function() {
            // Get data from results layer
            const exportData = [];
            resultsLayer.eachLayer(layer => {
                if (layer instanceof L.Circle) {
                    const data = layer.options.data;
                    if (data) {
                        exportData.push(data);
                    }
                }
            });
            
            if (exportData.length > 0) {
                exportToCSV(exportData);
                logger.log(`Exported ${exportData.length} points to CSV`);
            } else {
                alert("No data to export. Run the analysis first.");
                logger.warn("Export attempted with no data");
            }
        };
        document.querySelector('.info-panel').appendChild(exportButton);
        
        // Hide loading screen initially
        document.getElementById('loadingScreen').style.display = 'none';
        
        // Log initialization complete
        logger.log("Application initialized and ready");
    </script>
</body>
</html>